<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <h1>Emerging images effect on scroll</h1>
    <p>Having objects appear on scroll is almost a standard nowadays. Yet, there are not too many options when it comes to HTML. So i decided to spice it up a little with some WebGL effects!</p>

    <h2>Starting with a Plane</h2>
    <p>Let's just look at a simplest PlaneGeometry object with a ShaderMaterial. What can we do here?</p>
    <img src="post/start.png" alt="">
    <p>Well, actually a lot of things! You can check out the <a href="https://tympanus.net/codrops/2020/01/22/how-to-unroll-images-with-three-js/">tutorial on unrolling images</a>.</p>
    <p>But this time i wanted to explore more pixelated effects. So how do you achieve pixellisation in shaders?</p>
    <p>It's actually quite simple. You just have to round the UVs to the nearest pixel. And that's it! You have a pixelated effect. Let's say we want 10 "pixel" grid:</p>
    <pre lang="glsl">
        vec2 uv = floor(vUv * 10.0) / 10.0;
    </pre>
    <img src="post/pixelized.png" alt="">
    <p>These are UVs, but by sampling the texture with them you will get this effect:</p>
    <img src="post/pixelated.jpg" alt="">
    <p>Just to underline the effect a little i have also added borders to each pixel:</p>

    <img src="post/borders.png" alt="">
    <p>Another small caveat is that if image is not square, you will get equal amount of rows and columns, hence - pixels wont be squares anymore. To work around that, instead of multiplying UVs with scalar value, we can do that with <code>vec2</code></p>

    <pre lang="glsl">
        vec2 gridSize = vec2(
            20., 
            floor(20./ASPECT_RATIO)
        );
        vec2 uv = floor(vUv * gridSize) / gridSize;
    </pre>
    <img src="post/squares.jpg" alt="">
    <p>This way we will have roughly square pixels, but also an integer amount of them in rows and columns! On top of it i added a couple more simple effects, like background curtain and changing amount of pixellisation. Here is the nice  result:</p>

    <video src="post/animation.mp4" autoplay muted loop playsinline></video>

    <h2>Scroll?</h2>
    <p>There is a number of ways to connect HTML and our new effect. The simplest one nowadays would be to use React Three Fiber.</p>
    <p>R3F has an  amazing library of helpful modules thanks to <a href="https://pmnd.rs/">Poimandres team</a>. The library name is Drei and it has a <a href="https://github.com/pmndrs/drei?tab=readme-ov-file#view"">&#x3C;View /&#x3E;</a> component there.</p>
    <p>The idea of this component is to be able to insert parts of your 3D scene right into your DOM. Which, yes, is basically magic (the one indistinguishable from advanced enough scienceðŸ˜…)</p>
    <p>This example is right from the docs:</p>
    <pre lang="jsx"> //react code
        return (
            &lt;main ref={container}&gt;
                &lt;h1&gt;Html content here&lt;/h1&gt;
                &lt;!-- here we go, MESH in HTML, just like that --&gt;
                &lt;View style={{ width: 200, height: 200 }} className=&quot;canvas-view&quot;&gt;
                    &lt;mesh geometry={foo} /&gt;
                    &lt;OrbitControls /&gt;
                &lt;/View&gt;
                &lt;Canvas eventSource={container}&gt;
                &lt;View.Port /&gt; // this is where our Views will be in 3D world
                &lt;/Canvas&gt;
            &lt;/main&gt;
            )
    </pre>
    <p>So, as you can see, we can just put our Three.js objects right into our HTML. And, as a bonus, we can use native HTML events to control them. This is a huge step forward in terms of integration of these two worlds. </p>
    <p>So for my demo i was able to use native IntersectionObserver API to run all the animations in WebGL!</p>
    <p>The last annoying bit is syncronisation issue between WebGL and HTML. Because those are still two different layers. All the WebGL is being rendered in fullscreen canvas on top of your page. These two worlds has to scroll together. And if you decide to use native scroll. Which is, well, natural. You will have a situation when HTML scrolls natively, and WebGL scrolls when it gets scroll event. </p>
    <p>You could imagine those are the same thing, but there will be a slight delay and jiggering between layers</p>
    <video src="post/jitter.mp4" autoplay muted loop></video>

    <p>To overcome this, you should use custom scrolling solutions. Like Lenis or Locomotive scroll. In my case i used Lenis, as a global effect inside React Three Fiber:</p>

    <pre lang="js">
        import { addEffect } from "@react-three/fiber";
        import Lenis from "@studio-freight/lenis";

        const lenis = new Lenis();
        addEffect((t) => lenis.raf(t));
    </pre>

    <p>So, now once our &lt;View /&gt; is inside viewport i will just change my materail uniform uProgress from 0 to 1. And that's it! I have a shader animation in HTML.</p>

    <p>Another important thing to note here, is that even tho declaratively we have HTML and WebGL mixed up in this wonderful cocktail. They are two separate worlds, and, for example, usual React Three Fiber hooks, will not work with &lt;View /&gt; components.
        <pre lang="jsx">
            function MyView(){
                const { scene } = useThree()
                <span style="color:red">>>R3F: Hooks can only be used within the Canvas component!</span>
                return (
                    &lt;View style={{ width: 200, height: 200 }} className=&quot;canvas-view&quot;&gt;
                        &lt;mesh geometry={foo} /&gt;
                        &lt;OrbitControls /&gt;
                    &lt;/View&gt;
                )
            }
        </pre>

    <p>Because even though it is being inserted into Three.js scene via &lt;View.port&gt;, it's not really from WebGL root. It all looks so simple, but you have to keep in mind what is actually going on behind the scenes to understand these caveats.</p>
    <p>But even taking these into account, you just cant underestimate how simple these things are becoming with React. I dont really like using React for animated scrollable landings, but, when integration is THAT easy, i will have to think thrice.</p>
    <h2>Final</h2>
    <p>I hope you liked this integration example, share your ways of animating images, or examples that you like! And support open source developers, thanks to them we have such amazing infrastructures nowadays.</p>






    
</body>
</html>